/*=====================(C) COPYRIGHT 2008 Insem Inc.=========================
program 		:   
processor	  : STM32F103xx
compiler		: IAR 6.41A Compiler 
program BY 	: H.H.Hwang
date 			  : 2013.	  .
copy right 	: Plus - H.
===========================================================================*/


#define __UART2_H__

#include "stm32f10x_lib.h"
#include "main.h"



//=======================================================================
/* UART1_initial	:								              */												
//=======================================================================
void UART2_initial(void){
GPIO_InitTypeDef GPIO_InitStructure;
USART_InitTypeDef USART_InitStructure;
NVIC_InitTypeDef NVIC_InitStructure;

  /* RS485 UART2 Direction port define */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);


	/* Enable GPIOA and USART2 clocks */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_AFIO, ENABLE);
	 /* Enable USART2 clocks */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);

  
  /* Configure USART2 Tx (PA9) as alternate function push-pull */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  GPIO_Init(GPIOA, &GPIO_InitStructure);

  /* Configure USART2 Rx (PA10) as input floating */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
  GPIO_Init(GPIOA, &GPIO_InitStructure);

/* USART2 configuration ------------------------------------------------------*/
  /* USART2 configured as follow:
        - BaudRate = 115200 baud  
        - Word Length = 8 Bits
        - one Stop Bit
        - No parity
        - Hardware flow control disabled (RTS and CTS signals)
        - Receive and transmit enabled
        - USART Clock disabled
        - USART CPOL: Clock is active low
        - USART CPHA: Data is captured on the second edge 
        - USART LastBit: The clock pulse of the last data bit is not output to 
                         the SCLK pin
  */
  USART_InitStructure.USART_BaudRate = 19200;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
  USART_InitStructure.USART_Parity = USART_Parity_No;
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
//  USART_InitStructure.USART_Clock = USART_Clock_Disable;
//  USART_InitStructure.USART_CPOL = USART_CPOL_Low;
//  USART_InitStructure.USART_CPHA = USART_CPHA_2Edge;
//  USART_InitStructure.USART_LastBit = USART_LastBit_Disable;

  /* Configure the USART1 */
  USART_Init(USART2, &USART_InitStructure);

/* Enable the USART Transmoit interrupt: this interrupt is generated when the 
   USART1 transmit data register is empty */  
//  USART_ITConfig(USART2, USART_IT_TXE, ENABLE);

/* Enable the USART Receive interrupt: this interrupt is generated when the 
   USART1 receive data register is not empty */
  USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);

  /* Enable USART1 */
  USART_Cmd(USART2, ENABLE);

  /* Enable the USART1 Interrupt */
  NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQChannel;
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);
}



//=======================================================================
void uart2_frame_proc() 
{

  UART2_tx_check();
  UART2_rx_check();
  
}

/* UART1 data arrange routine */
void volume_jig_data_set(void)
{
  unsigned char crc = 0;
  unsigned char i = 0,j;
  
  
  P_UART2_DIR = 1;
  uart2_tx_data_buf[i++] = ' ';                               //Preamble
  uart2_tx_data_buf[i++] = '(';                               //STX
  ++i;
  uart2_tx_data_buf[i++] = 0x01;                           //Device bit
  uart2_tx_data_buf[i++] = 0xca;                           //Device ID
  uart2_tx_data_buf[i++] = room_data_buf[79];             //Data#1
  uart2_tx_data_buf[i++] = room_data_buf[80];             //Data#n
  uart2_tx_data_buf[2] = i+1;                               //Length
  for(j=1; j<i; ++j) crc += uart2_tx_data_buf[j];
  crc ^= 0x55;
  uart2_tx_data_buf[i++] = crc;                               //CRC
  uart2_tx_data_buf[i++] = ')';                               //ETX

  f_uart2_data_send = 1;
  uart2_tx_length = 0;
  uart2_tx_backup = i;

  
 
}


/* UART1 data arrange routine */
void UART2_data_set(unsigned char id_kind,unsigned char id_bit)
{
//  unsigned char crc = 0;
  unsigned char i = 0,j;
  
//  unsigned char temp = 0x01;
/*  
  P_UART2_DIR = 1;
  uart2_tx_data_buf[i++] = ' ';                               //Preamble
  uart2_tx_data_buf[i++] = '(';                               //STX
  ++i;
  uart2_tx_data_buf[i++] = id_bit;                           //Device bit
  uart2_tx_data_buf[i++] = id_kind;                           //Device ID
  uart2_tx_data_buf[i++] = 0;                                 //Data#1
  uart2_tx_data_buf[i++] = 0;                                 //Data#n
  uart2_tx_data_buf[2] = i+1;                               //Length
  for(j=1; j<i; ++j) crc += uart2_tx_data_buf[j];
  crc ^= 0x55;
  uart2_tx_data_buf[i++] = crc;                               //CRC
  uart2_tx_data_buf[i++] = ')';                               //ETX

  f_uart2_data_send = 1;
  uart2_tx_length = 0;
  uart2_tx_backup = i;
 */ 
  
  P_UART2_DIR = 1;
  uart2_tx_data_buf[i++] = ' ';                               //Preamble
  uart2_tx_data_buf[i++] = '(';                               //STX
  uart2_tx_data_buf[i++] = eep_err_status;
  for(j=0; j<8; ++j){
    uart2_tx_data_buf[i++] = i2c_temp_buf[j];
  }
  uart2_tx_data_buf[i++] = ')';                               //STX
  f_uart2_data_send = 1;
  uart2_tx_length = 0;
  uart2_tx_backup = i;
 
}

//
//============ Thermo sensor data arrange routine =======================
//
void Thermo_sensor_data_set(unsigned char index, unsigned char index_bit)
{
  unsigned char crc = 0;
  unsigned char i=0,j;
 
  P_UART2_DIR = 1;
  uart2_tx_data_buf[i++] = ' ';                               //Preamble
  uart2_tx_data_buf[i++] = '(';                               //STX
  ++i;                                                        //Length point(아래에서 처리)
  uart2_tx_data_buf[i++] = 0x55;  //index_bit;                         //Device bit
  uart2_tx_data_buf[i++] = index+0x10;                        //Device ID
  
  if(index_bit & 0x01){
    if(f_ts_power_on[0]){
      uart2_tx_data_buf[i++] = room_data_buf[0];
    }
    else uart2_tx_data_buf[i++] = ts_air_set_temp_from_PC[0];
    uart2_tx_data_buf[i++] = ts_floor_set_temp_from_PC[0];
    uart2_tx_data_buf[i++] = ts_switch_toggle_bit[0];
    uart2_tx_data_buf[i++] = ts_status_read(0);
    uart2_tx_data_buf[i++] = ts_control_data_read(0);
  }
  if(index_bit & 0x02){
    if(f_ts_power_on[1])  uart2_tx_data_buf[i++] = room_data_buf[1];
    else uart2_tx_data_buf[i++] = ts_air_set_temp_from_PC[1];
    uart2_tx_data_buf[i++] = ts_floor_set_temp_from_PC[1];
    uart2_tx_data_buf[i++] = ts_switch_toggle_bit[1];
    uart2_tx_data_buf[i++] = ts_status_read(1);
    uart2_tx_data_buf[i++] = ts_control_data_read(1);
  }
  if(index_bit & 0x04){
    if(f_ts_power_on[2])  uart2_tx_data_buf[i++] = room_data_buf[2];
    else uart2_tx_data_buf[i++] = ts_air_set_temp_from_PC[2];
    uart2_tx_data_buf[i++] = ts_floor_set_temp_from_PC[2];
    uart2_tx_data_buf[i++] = ts_switch_toggle_bit[2];
    uart2_tx_data_buf[i++] = ts_status_read(2);
    uart2_tx_data_buf[i++] = ts_control_data_read(2);
  }
  if(index_bit & 0x08){
    if(f_ts_power_on[3])  uart2_tx_data_buf[i++] = room_data_buf[4];
    else uart2_tx_data_buf[i++] = ts_air_set_temp_from_PC[3];
    uart2_tx_data_buf[i++] = ts_floor_set_temp_from_PC[3];
    uart2_tx_data_buf[i++] = ts_switch_toggle_bit[3];
    uart2_tx_data_buf[i++] = ts_status_read(3);
    uart2_tx_data_buf[i++] = ts_control_data_read(3);
  }
  uart2_tx_data_buf[i++] = room_data_buf[28];               //대기 상.하한 온도
  uart2_tx_data_buf[i++] = room_data_buf[29];               //바닥 상.하한 온도
  uart2_tx_data_buf[i++] = room_data_buf[30];               //외기 온도
  
  uart2_tx_data_buf[i++] = bojung_temp[index];              //보정온도 h@20140704
  
  uart2_tx_data_buf[2] = i+1;                               //Length
  for(j=1; j<i; ++j) crc += uart2_tx_data_buf[j];
  crc ^= 0x55;
  uart2_tx_data_buf[i++] = crc;                             //CRC
  uart2_tx_data_buf[i++] = ')';                             //ETX

  f_uart2_data_send = 1;
  uart2_tx_length = 0;
  uart2_tx_backup = i;
  
  if(++ts_set_temp_send_count[index] > 3){
    ts_set_temp_send_count[index] = 5;
    ts_air_set_temp_from_PC[index] = 0xff;
    ts_floor_set_temp_from_PC[index] = 0xff;
  }
  
  
}

unsigned char ts_status_read(unsigned char index)
{
  unsigned char return_data = 0;
  
  if(room_data_buf[40] & 0x01) return_data |= 0x01;         //Check IN 
  if(room_data_buf[40] & 0x02) return_data |= 0x02;         //Guest IN
  if(room_data_buf[20+index] & 0x04) return_data |= 0x04;   //Cool mode
  switch(room_data_buf[24+index] & 0x30)
  {
    case 0x00: return_data |= 0x00;    break;               //대기전용
    case 0x10: return_data |= 0x08;    break;               //바닥전용
    case 0x20: return_data |= 0x10;    break;               //대기/바닥 동시제어
  }
  if(room_data_buf[40] & 0x10) return_data |= 0x20;         //Windows OPEN
  if(room_data_buf[74] == 2) return_data |= 0x40;           //환절기 mode
  if(room_data_buf[41] & 0x08) return_data |= 0x80;         //온도표시방법 1=설정온도표시, 0=현재온도표시
  return(return_data);
}
unsigned char ts_control_data_read(unsigned char index)
{
  unsigned char return_data = 0;
  
  return_data = room_data_buf[16+index] & 0x03;             //Speed data
  if(room_data_buf[16+index] & 0x10) return_data |= 0x04;   //바닥밸브 open or close?
  if(room_data_buf[16+index] & 0x04) return_data |= 0x08;   //대기센서 스위치 ON/OFF?
  if(room_data_buf[16+index] & 0x20) return_data |= 0x10;   //바닥센서 스위치 ON/OFF?
  //  if(room_data_buf[24+index] & 0x08) return_data |= 0x20;   //화씨 or 도씨?       //h@20150910
  //if(room_data_buf[20+index] & 0x40) return_data |= 0x20;       //송풍모드          //h@20150910
  if(room_data_buf[20+index] & 0x08) return_data |= 0x40;   //Auto or Manual mode
  if(f_ts_power_on[index] == 1) return_data |= 0x80;   //Auto or Manual mode
  return(return_data);
}

//
//================ Night Table data arrange routine ===================
//
void night_table_data_set(unsigned char index, unsigned char index_bit)
{
  unsigned char crc = 0;
  unsigned char i=0,j;
  unsigned char led_temp = 0;
 
  P_UART2_DIR = 1;
  uart2_tx_data_buf[i++] = ' ';                               //Preamble
  uart2_tx_data_buf[i++] = '(';                               //STX
  ++i;                                                        //Length point(아래에서 처리)
  uart2_tx_data_buf[i++] = 0x55;  //index_bit;                         //Device bit
  uart2_tx_data_buf[i++] = index + 0x20;                      //Device ID
  
  if(index_bit & 0x01){
//    uart2_tx_data_buf[i++] = ((room_data_buf[45] & 0x7f) >> 2);  //room_data_buf[50+index];
    if(room_data_buf[45] & 0x04) led_temp |= 0x01;
    if(room_data_buf[45] & 0x10) led_temp |= 0x02;
    if(room_data_buf[45] & 0x40) led_temp |= 0x04;
    if(room_data_buf[45] & 0x80) led_temp |= 0x08;
    uart2_tx_data_buf[i++] = led_temp;
      
    uart2_tx_data_buf[i++] = nt_switch_toggle_bit[index][0];
    uart2_tx_data_buf[i++] = nt_switch_toggle_bit[index][1];
    uart2_tx_data_buf[i++] = nt_switch_toggle_bit[index][2];
    uart2_tx_data_buf[i++] = nt_control_data_read(index);
  }
  if(index_bit & 0x02){
    uart2_tx_data_buf[i++] = room_data_buf[index+50];
    uart2_tx_data_buf[i++] = nt_switch_toggle_bit[index][0];
    uart2_tx_data_buf[i++] = nt_switch_toggle_bit[index][1];
    uart2_tx_data_buf[i++] = nt_switch_toggle_bit[index][2];
    uart2_tx_data_buf[i++] = nt_control_data_read(index);
  }
  if(index_bit & 0x04){
    uart2_tx_data_buf[i++] = room_data_buf[index+50];
    uart2_tx_data_buf[i++] = nt_switch_toggle_bit[index][0];
    uart2_tx_data_buf[i++] = nt_switch_toggle_bit[index][1];
    uart2_tx_data_buf[i++] = nt_switch_toggle_bit[index][2];
    uart2_tx_data_buf[i++] = nt_control_data_read(index);
  }
  if(index_bit & 0x08){
    uart2_tx_data_buf[i++] = room_data_buf[index+50];
    uart2_tx_data_buf[i++] = nt_switch_toggle_bit[index][0];
    uart2_tx_data_buf[i++] = nt_switch_toggle_bit[index][1];
    uart2_tx_data_buf[i++] = nt_switch_toggle_bit[index][2];
    uart2_tx_data_buf[i++] = nt_control_data_read(index);
  }
  uart2_tx_data_buf[i++] = nt_room_status();
  
  uart2_tx_data_buf[i++] = room_data_buf[90];   //year
//  uart2_tx_data_buf[i++] = room_data_buf[91];   //month
  if(f_ts_power_on[1])  uart2_tx_data_buf[i++] = room_data_buf[1];  //TS2 set temp
  else uart2_tx_data_buf[i++] = ts_air_set_temp_from_PC[1];
//  uart2_tx_data_buf[i++] = room_data_buf[92];   //day
  uart2_tx_data_buf[i++] = room_data_buf[5];    //TS2 check temp
  
  
  uart2_tx_data_buf[i++] = room_data_buf[93];   //hour
  uart2_tx_data_buf[i++] = room_data_buf[94];   //min

  uart2_tx_data_buf[2] = i+1;                               //Length
  for(j=1; j<i; ++j) crc += uart2_tx_data_buf[j];
  crc ^= 0x55;
  uart2_tx_data_buf[i++] = crc;                             //CRC
  uart2_tx_data_buf[i++] = ')';                             //ETX

  f_uart2_data_send = 1;
  uart2_tx_length = 0;
  uart2_tx_backup = i;
 
  if(++ts_set_temp_send_count[1] > 3){
    ts_set_temp_send_count[1] = 5;
    ts_air_set_temp_from_PC[1] = 0xff;
    ts_floor_set_temp_from_PC[1] = 0xff;
  }  
}

unsigned char nt_control_data_read(unsigned char index)
{
  unsigned char return_data = 0;
/* 
  return_data = room_data_buf[16+index] & 0x03;             //Speed data
  if(room_data_buf[16+index] & 0x04) return_data |= 0x04;   //TS ON/OFF status
  if(room_data_buf[20+index] & 0x04) return_data |= 0x08;   //Cool or warm
  if(room_data_buf[36+index] & 0x08) return_data |= 0x10;   //Radio on?
  return_data |= ((room_data_buf[36+index] & 0x07) << 5);   //Radio channel
  return(return_data);
*/
//부전동 호텔 NT에서 온도센서2의 역할을 한다.  
  return_data = room_data_buf[17] & 0x03;             //Speed data
  if(room_data_buf[17] & 0x04) return_data |= 0x04;   //TS ON/OFF status
  if(room_data_buf[21] & 0x04) return_data |= 0x08;   //Cool or warm
  if(room_data_buf[36+index] & 0x08) return_data |= 0x10;   //Radio on?
  return_data |= ((room_data_buf[36+index] & 0x07) << 5);   //Radio channel
  return(return_data);  
}

unsigned char nt_room_status(void)
{
  unsigned char return_data = 0;
  
  if(room_data_buf[40] & 0x01) return_data |= 0x01;         //Check IN 
  if(room_data_buf[40] & 0x02) return_data |= 0x02;         //Guest IN
  if(room_data_buf[20] & 0x04) return_data |= 0x04;         //Cool mode
  if(room_data_buf[40] & 0x04) return_data |= 0x08;         //DND
  if(room_data_buf[40] & 0x08) return_data |= 0x10;         //MUR
  if(room_data_buf[40] & 0x10) return_data |= 0x20;         //Window
  if(room_data_buf[40] & 0x20) return_data |= 0x40;         //Message
  if(room_data_buf[40] & 0x40) return_data |= 0x80;         //Door open
  return(return_data);

  
}


//
//================ Light switch data arrange routine ===================
//
void light_switch_data_set(unsigned char index, unsigned char index_bit)
{
  unsigned char crc = 0;
  unsigned char i=0,j;
  
  P_UART2_DIR = 1;
  uart2_tx_data_buf[i++] = ' ';                               //Preamble
  uart2_tx_data_buf[i++] = '(';                               //STX
  ++i;                                                        //Length point(아래에서 처리)
  uart2_tx_data_buf[i++] = 0x54;  //index_bit;                //Device bit
  uart2_tx_data_buf[i++] = index + 0x30;                      //Device ID
  
  if(index_bit & 0x01) // 객실 3구 
  {
    uart2_tx_data_buf[i] = 0;
    
    if(room_data_buf[45] & 0x02) uart2_tx_data_buf[i] |= 0x02; //STAND1 LED
    if(room_data_buf[45] & 0x04) uart2_tx_data_buf[i] |= 0x04; //STAND2 LED
    if((room_data_buf[47] & 0x01) == 0) uart2_tx_data_buf[i] |= 0x08; //REST MASTER LED
    if((room_data_buf[45] & 0x06) == 0) uart2_tx_data_buf[i] |= 0x01; //MASTER LED
    else uart2_tx_data_buf[i] &= 0x0e; 
    
    ++i;
    uart2_tx_data_buf[i++] = light_switch_toggle_bit[index][0];
    uart2_tx_data_buf[i++] = ls_control_data_read(index);
  }
  if(index_bit & 0x02) // 객실 1구(화장실)
  {
    uart2_tx_data_buf[i] = 0;
    
    if(room_data_buf[47] & 0x01) uart2_tx_data_buf[i] |= 0x01;
        
    ++i;
    uart2_tx_data_buf[i++] = light_switch_toggle_bit[index][0];
    uart2_tx_data_buf[i++] = ls_control_data_read(index);
  }
  if(index_bit & 0x04) //객실 3구(특실)
  {
    uart2_tx_data_buf[i] = 0;
    
    if(room_data_buf[46] & 0x01) uart2_tx_data_buf[i] |= 0x02; //STAND1 LED
    if(room_data_buf[46] & 0x02) uart2_tx_data_buf[i] |= 0x04; //STAND2 LED
    if(room_data_buf[46] & 0x04) uart2_tx_data_buf[i] |= 0x08; //STAND3 LED
    if((room_data_buf[46] & 0x07) == 0) uart2_tx_data_buf[i] |= 0x01; //MASTER LED
    else uart2_tx_data_buf[i] &= 0x0e; 
    
    ++i;
    uart2_tx_data_buf[i++] = light_switch_toggle_bit[index][0];
    uart2_tx_data_buf[i++] = ls_control_data_read(index);      
  }
  
  uart2_tx_data_buf[2] = i+1;                               //Length
  for(j=1; j<i; ++j) crc += uart2_tx_data_buf[j];
  crc ^= 0x55;
  uart2_tx_data_buf[i++] = crc;                             //CRC
  uart2_tx_data_buf[i++] = ')';                             //ETX

  f_uart2_data_send = 1;
  uart2_tx_length = 0;
  uart2_tx_backup = i;
  
}

unsigned char ls_control_data_read(unsigned char index)
{
  unsigned char return_data = 0;
  
  if(room_data_buf[40] & 0x01) return_data |= 0x01;         //Check IN 
  if(room_data_buf[40] & 0x02) return_data |= 0x02;         //Guest IN
 // if(room_data_buf[40] & 0x80) return_data |= 0x04;         //Please wait sign
  //if(room_data_buf[40] & 0x04) return_data |= 0x08;         //DND
 // if(room_data_buf[40] & 0x08) return_data |= 0x10;         //MUR
  if(room_data_buf[40] & 0x10) return_data |= 0x20;         //Window
  if(room_data_buf[40] & 0x20) return_data |= 0x40;         //Message
  if(room_data_buf[40] & 0x40) return_data |= 0x80;         //Door open
  return(return_data);
}


//
//========== Key sensor data arrange =============
//
void key_sendor_data_set(unsigned char index,unsigned char index_bit)
{
  unsigned char crc = 0;
  unsigned char i=0,j;
 
  P_UART2_DIR = 1;
  uart2_tx_data_buf[i++] = ' ';                               //Preamble
  uart2_tx_data_buf[i++] = '(';                               //STX
  ++i;                                                        //Length point(아래에서 처리)
  uart2_tx_data_buf[i++] = 0x55;  //index_bit;                         //Device bit
  uart2_tx_data_buf[i++] = index + 0x60;                      //Device ID
  
  if(index_bit & 0x01){
    uart2_tx_data_buf[i++] = ks_switch_toggle_bit[index];
    uart2_tx_data_buf[i++] = ks_control_data_read(index);
  }
  if(index_bit & 0x02){
    uart2_tx_data_buf[i++] = ks_switch_toggle_bit[index];
    uart2_tx_data_buf[i++] = ks_control_data_read(index);
  }

  uart2_tx_data_buf[2] = i+1;                               //Length
  for(j=1; j<i; ++j) crc += uart2_tx_data_buf[j];
  crc ^= 0x55;
  uart2_tx_data_buf[i++] = crc;                             //CRC
  uart2_tx_data_buf[i++] = ')';                             //ETX
  
  f_uart2_data_send = 1;
  uart2_tx_length = 0;
  uart2_tx_backup = i;
  
}

unsigned char ks_control_data_read(unsigned char index)
{
  unsigned char return_data = 0;
  
  if(room_data_buf[40] & 0x01) return_data |= 0x01;         //Check IN 
  if(room_data_buf[40] & 0x02) return_data |= 0x02;         //Guest IN
  if(room_data_buf[40] & 0x04) return_data |= 0x10;         //DND
  if(room_data_buf[40] & 0x08) return_data |= 0x20;         //MUR
  //if(room_data_buf[46] & 0x04) return_data |= 0x10;         //전열교환기 상태
  //if(room_data_buf[45] & 0x02) return_data |= 0x20;         //입구등 상태
  return(return_data);
}

void dimmer_data_set(void)
{
  unsigned char crc = 0;
  unsigned char i = 0,j;
  
  P_UART2_DIR = 1;
  uart2_tx_data_buf[i++] = ' ';                               //Preamble
  uart2_tx_data_buf[i++] = '(';                               //STX
  ++i;
  uart2_tx_data_buf[i++] = 0x56;  //0x01;                     //Device bit
  uart2_tx_data_buf[i++] = 0x40;                              //Device ID
  uart2_tx_data_buf[i++] = dimmer_level[3];                   //Data#1
  uart2_tx_data_buf[i++] = dimmer_level[1];                   //Data#1
  uart2_tx_data_buf[i++] = dimmer_level[2];                   //Data#1 LIGHT SW 2
  uart2_tx_data_buf[i++] = dimmer_level[0];                   //Data#1 LIGHT SW 1
  uart2_tx_data_buf[2] = i+1;                                 //Length
  for(j=1; j<i; ++j) crc += uart2_tx_data_buf[j];
  crc ^= 0x55;
  uart2_tx_data_buf[i++] = crc;                               //CRC
  uart2_tx_data_buf[i++] = ')';                               //ETX

  f_uart2_data_send = 1;
  uart2_tx_length = 0;
  uart2_tx_backup = i;
  
}

void audio_data_set(void)
{
  unsigned char crc = 0;
  unsigned char i = 0,j;
  unsigned char temp=0;
  
  
  
  P_UART2_DIR = 1;
  uart2_tx_data_buf[i++] = ' ';                               //Preamble
  uart2_tx_data_buf[i++] = '(';                               //STX
  ++i;
  uart2_tx_data_buf[i++] = 0x55;  //0x01;                           //Device bit
  uart2_tx_data_buf[i++] = 0x70;                           //Device ID
  if(room_data_buf[40] & 0x02) temp |= 0x01;              //Guest IN
  if(f_chime_keep) temp |= 0x02;                //Chime ON
  if(f_alram_on)   temp |= 0x04;                //Alram ON
  if(room_data_buf[36] & 0x08) temp |= 0x08;              //Audio ON
  if(room_data_buf[40] & 0x04) temp |= 0x10;              //DND ON
  if(room_data_buf[40] & 0x08) temp |= 0x20;              //MUR ON
  if(room_data_buf[36] & 0x40) temp |= 0x40;              //MUTE ON
  
  uart2_tx_data_buf[i++] = temp;
  uart2_tx_data_buf[i++] = room_data_buf[36] & 0x07;      //Radio channel
  
  uart2_tx_data_buf[i++] = audio_volume[0];             //Audio volume
  uart2_tx_data_buf[i++] = room_data_buf[79];           //Chime volume
  uart2_tx_data_buf[i++] = room_data_buf[80];           //Alram volume
  uart2_tx_data_buf[2] = i+1;                               //Length
  for(j=1; j<i; ++j) crc += uart2_tx_data_buf[j];
  crc ^= 0x55;
  uart2_tx_data_buf[i++] = crc;                               //CRC
  uart2_tx_data_buf[i++] = ')';                               //ETX

  f_uart2_data_send = 1;
  uart2_tx_length = 0;
  uart2_tx_backup = i;
  
}

void chime_ind_data_set(void)
{
  unsigned char crc = 0;
  unsigned char i=0,j;
  
  P_UART2_DIR = 1;
  uart2_tx_data_buf[i++] = ' ';                               //Preamble
  uart2_tx_data_buf[i++] = '(';                               //STX
  ++i;                                                        //Length point(아래에서 처리)
  uart2_tx_data_buf[i++] = 0x54;  //0x01;                     //Device bit
  uart2_tx_data_buf[i++] = 0x50;                              //Device ID
  
  uart2_tx_data_buf[i++] = 0;
  uart2_tx_data_buf[i++] = chime_ind_toggle_bit[0];
  uart2_tx_data_buf[i++] = ls_control_data_read(0);
  
  uart2_tx_data_buf[2] = i+1;                               //Length
  for(j=1; j<i; ++j) crc += uart2_tx_data_buf[j];
  crc ^= 0x55;
  uart2_tx_data_buf[i++] = crc;                             //CRC
  uart2_tx_data_buf[i++] = ')';                             //ETX
  
  f_uart2_data_send = 1;
  uart2_tx_length = 0;
  uart2_tx_backup = i;
  
}

void common_data_set(void)
{
  unsigned char crc = 0;
  unsigned char i = 0,j;
  unsigned char temp=0;
    
  P_UART2_DIR = 1;
  uart2_tx_data_buf[i++] = ' ';                         //Preamble
  uart2_tx_data_buf[i++] = '(';                         //STX
  ++i;
  uart2_tx_data_buf[i++] = 0xff;                        //Device ID
  uart2_tx_data_buf[i++] = 0xff;                        //Device ID
  
  if(room_data_buf[40] & 0x01) temp |= 0x01;            //Check IN 
  if(room_data_buf[40] & 0x02) temp |= 0x02;            //Guest IN
  if(room_data_buf[40] & 0x10) temp |= 0x04;            //Window
  if(room_data_buf[20] & 0x04) temp |= 0x08;            //Cool mode
  if(room_data_buf[40] & 0x04) temp |= 0x10;            //DND
  if(room_data_buf[40] & 0x08) temp |= 0x20;            //MUR
  if(room_data_buf[82] & 0x08) temp |= 0x80;            //현재조도상태 1=밝게하라(밝다),0=어둡게하라(어둡다)
  uart2_tx_data_buf[i++] = temp;
  uart2_tx_data_buf[i++] = room_data_buf[82];           //조도 조절법, 복귀시간 및 현재 상태
  
  uart2_tx_data_buf[2] = i+1;                           //Length
  for(j=1; j<i; ++j) crc += uart2_tx_data_buf[j];
  crc ^= 0x55;
  uart2_tx_data_buf[i++] = crc;                         //CRC
  uart2_tx_data_buf[i++] = ')';                         //ETX
  
  f_uart2_data_send = 1;
  uart2_tx_length = 0;
  uart2_tx_backup = i;
  
}

/* UART2 data send check routine */
void UART2_tx_check(void)
{
  if(f_uart2_data_send){
	  if(USART_GetFlagStatus(USART2, USART_FLAG_TC) !=RESET) {
      if(uart2_tx_length < uart2_tx_backup){
        USART2->DR = (uart2_tx_data_buf[uart2_tx_length++] & (u16)0x01FF);
      }
      else{
        P_UART2_DIR = 0;
        f_uart2_data_send = 0;
        sub_call_timer = 15;
      }
    }
  }
}

//=======================================================================
void UART2_control_proc(void) 
{
//u8 ix;
  unsigned char sub_device_kind;

  if(f_uart2_send_time){
    f_uart2_send_time = 0;
    
    if(f_volume_control)  volume_jig_data_set();
    else{
      if(f_common_send_time){ 
        common_data_set();  
        f_common_send_time = 0; 
      }
      else{
        if(b_sub_device_table[cb_mode][id_number] == 0xff) id_number = 0;
        sub_device_kind = b_sub_device_table[cb_mode][id_number++];
        switch(sub_device_kind){
          case B_KEY_SENSOR_0:
            key_sendor_data_set(0,0x01);
            break;  
          case B_TEMP_SENSOR_1:
            Thermo_sensor_data_set(0,0x01);
            break;  
          case B_TEMP_SENSOR_2:
            Thermo_sensor_data_set(1,0x02);
            break;  
          case B_TEMP_SENSOR_3:
            Thermo_sensor_data_set(2,0x04);
            break;  
          case B_TEMP_SENSOR_4:
            Thermo_sensor_data_set(3,0x08);
            break;  
          case B_NIGHT_TABLE_1:
            night_table_data_set(0,0x01);
            break;  
          case B_NIGHT_TABLE_2:
            night_table_data_set(1,0x02);
            break;  
          case B_LIGHT_SWITCH_1:
            light_switch_data_set(0,0x01);
            break;  
          case B_LIGHT_SWITCH_2:
            light_switch_data_set(1,0x02);
            break;  
          case B_LIGHT_SWITCH_3:
            light_switch_data_set(2,0x04);
            break;  
          case B_LIGHT_SWITCH_4:
            light_switch_data_set(3,0x08);
            break;  
            
          case B_DIMMER:
            dimmer_data_set();
            break;
            
          case B_AUDIO:
            audio_data_set();
            break;
            
          case B_CHIME_IND:
            chime_ind_data_set();
            break;
        }
      }
    }
  }
	uart2_frame_proc();
  


}






void UART2_rx_check(void)
{
  unsigned char rx_crc=0;
  unsigned char i;
  
  if(f_uart2_frame_rx_ok){
    f_uart2_frame_rx_ok = 0;
      
    for(i=0; i<uart2_rxd_buf[1]-2; ++i) rx_crc += uart2_rxd_buf[i];
    rx_crc ^= 0x55;
    if(rx_crc == (uart2_rxd_buf[uart2_rxd_buf[1]-2])){
      switch(uart2_rxd_buf[2] & 0xf0){
        case 0x10:    //Thermo sensor
          led3 ^= 1;
          thermo_sensor_check(uart2_rxd_buf[2] & 0x03);
          break;
        case 0x20:    //Night Table
          night_table_check(uart2_rxd_buf[2] & 0x03);
          break;
        case 0x30:    //Light switch
          light_switch_check(uart2_rxd_buf[2] & 0x03);
          break;
        case 0x40:    //Dimmer module
          dimmer_check(uart2_rxd_buf[2] & 0x03);
          break;
        case 0x50:    //Service Plate
            chime_ind_check(uart2_rxd_buf[2] & 0x03);    
          break;
        case 0x60:    //Key sensor
          key_sensor_rx_check(uart2_rxd_buf[2] & 0x03);
          break;
          
        case 0xc0:
          if(f_volume_control)
          {
            volume_data_check();
          }
          break;
      }
      sub_call_timer = 18;
   }

  }
}

//
//============= Volume set jig data check routine ===============
//
void volume_data_check(void)
{
  if(uart2_rxd_buf[2] == 0xca){
    if(uart2_rxd_buf[5] & 0x01){    //alram volume
      f_alram_on = 1;
      if(room_data_buf[80] != uart2_rxd_buf[4]){
        digital_volume_execution(1,room_data_buf[80]);
        room_data_buf[80] = uart2_rxd_buf[4];
      }
    }
    else{                           //chime volume
      f_alram_on = 0;
      if((jig_switch_toggle_bit & 0x01) != (uart2_rxd_buf[6] & 0x01)){
        room_data_buf[79] = uart2_rxd_buf[3];
        digital_volume_execution(0,room_data_buf[79]);
        if(!f_chime_keep){
          chime_sq = 0;
          f_chime_sq_timer = 1;
          f_chime_keep = 1;
        }
      }
    }
    jig_switch_toggle_bit = uart2_rxd_buf[6];
  }
}

//
//============= Thermo sensor receive data check routine ==============
//
void thermo_sensor_check(unsigned char index)
{
  if((uart2_rxd_buf[9] & 0x80) == 0){
    f_ts_power_on[index] = 0;
    if((uart2_rxd_buf[3] & 0x7f) <= 70){    //Air set temp
      if(room_data_buf[0+index] != uart2_rxd_buf[3]){
        room_data_buf[16+index] |= 0x80;
        room_data_buf[0+index] = uart2_rxd_buf[3];
        room_data_buf[99] |= 0x02;
      }
    }
    if((uart2_rxd_buf[4] & 0x7f) <= 70){    //Air Check temp
      room_data_buf[4+index] = uart2_rxd_buf[4];
      f_check_temp_change = 1;
//      room_data_buf[99] |= 0x02;            //현재온도 변경시 온도 Data 전송
    }
    if((room_data_buf[4+index] & 0x7f) > room_data_buf[76]){   //이상온도 비교
      if(++em_temp_count[index] > 3){                 //이상온도 3회 이상 발생?
        em_temp_count[index] = 0;
        room_data_buf[42] |= (0x10 << index);         //이상 온도 발생 flag set
        room_data_buf[45] |= 0x80;    //Fire sign ON
      }
    }
    else{
      //room_data_buf[42] &= (0xef << index);           //이상 온도 발생 flag clear
      switch(index)
      {
      case 0:
          room_data_buf[42] &= 0xef; //온도센서 1 em clear
        break;
      case 1:
          room_data_buf[42] &= 0xdf; //온도센서 2 em clear
        break;
      case 2:
          room_data_buf[42] &= 0xbf; //온도센서 3 em clear
        break;
      case 3:
          room_data_buf[42] &= 0x7f; //온도센서 4 em clear
        break;
      }
      em_temp_count[index] = 0;
      room_data_buf[45] &= 0x7f;    //Fire sign OFF
    }
    
    if((uart2_rxd_buf[5] & 0x7f) <= 70){    //Floor set temp
      if(room_data_buf[8+index] != uart2_rxd_buf[5]){
        room_data_buf[20+index] |= 0x80;
        room_data_buf[8+index] = uart2_rxd_buf[5];
        room_data_buf[99] |= 0x04;
      }
    }
    if((uart2_rxd_buf[6] & 0x7f) <= 70){    //Floor Check temp
      room_data_buf[12+index] = uart2_rxd_buf[6];
      f_check_temp_change_2 = 1;
    }
    if((uart2_rxd_buf[7] & 0x7f) <= 99){    //Humidity
      room_data_buf[31+index] = uart2_rxd_buf[7];
    }
    
    if(ts_first_power_on[index]){ 
      if(room_data_buf[40] & 0x02)
      {
      //First power on than only bit save
        if(ts_switch_toggle_bit[index] != uart2_rxd_buf[8]){    //TS switch push ?
          if((ts_switch_toggle_bit[index] & 0x01) != (uart2_rxd_buf[8] & 0x01)){    //TS on/off switch change(key push)
            room_data_buf[16+index] ^= 0x04;    //TS Air on/off toggle
            nt_switch_bit_check(K_fcu_auto_manual,index);
            room_data_buf[99] |= 0x02;
            room_data_buf[20+index] |= 0x08;    //Auto mode flag set
            room_data_buf[16+index] |= 0x80;
          }
          if((ts_switch_toggle_bit[index] & 0x02) != (uart2_rxd_buf[8] & 0x02)){    //TS floor mode on/off switch change(key push)
            room_data_buf[16+index] ^= 0x20;    //TS Floor on/off toggle
            room_data_buf[99] |= 0x04;
            room_data_buf[20+index] |= 0x80;
          }
          if((ts_switch_toggle_bit[index] & 0x10) != (uart2_rxd_buf[8] & 0x10)) room_data_buf[24+index] ^= 0x08;    //TS FaC, DoC
          if((ts_switch_toggle_bit[index] & 0x20) != (uart2_rxd_buf[8] & 0x20)) ts_speed_execution(index);          //TS local speed execution
          
          if((ts_switch_toggle_bit[index] & 0x40) != (uart2_rxd_buf[8] & 0x40)){  //Temp control mode(air,floor mode)
          /*  if(room_data_buf[74] == 2){   //환절기 모드일 경우만 적용한다.
              if(room_data_buf[83] >= 2) room_data_buf[83] = 0;   //0=auto, 1=warm, 2=cool
              else ++room_data_buf[83];
              room_data_buf[54+index] = 0;   //Auto mode
              room_data_buf[20+index] |= 0x80;
              switch(room_data_buf[83]){
                case 0: break;
                case 1:
                  room_data_buf[20] |= 0x04;    //냉방
                  room_data_buf[21] |= 0x04;    //냉방
                  room_data_buf[22] |= 0x04;    //냉방
                  room_data_buf[23] |= 0x04;    //냉방
                  if((room_data_buf[0] & 0x7f) >= (room_data_buf[4] & 0x7f)){
                    ts_air_set_temp_from_PC[0] = (room_data_buf[4] & 0x7f) - 2;
                    if(ts_air_set_temp_from_PC[0] < 18) ts_air_set_temp_from_PC[0] = 18;
                    ts_set_temp_send_count[0] = 0;
                  }
                  break;
                case 2:
                  room_data_buf[20] &= 0xfb;    //난방
                  room_data_buf[21] &= 0xfb;    //난방
                  room_data_buf[22] &= 0xfb;    //난방
                  room_data_buf[23] &= 0xfb;    //난방
                  
                  if((room_data_buf[0] & 0x7f) <= (room_data_buf[4] & 0x7f)){
                    ts_air_set_temp_from_PC[0] = (room_data_buf[4] & 0x7f) + 2;
                    if(ts_air_set_temp_from_PC[0] > 30) ts_air_set_temp_from_PC[0] = 30;
                    ts_set_temp_send_count[0] = 0;
                  }
                  break;
              }
              
              
            }*/
          }
          if(ts_switch_toggle_bit[index] & 0x80){               //Set temp CB execution?
            //if((ts_switch_toggle_bit[index] & 0x04) != (uart2_rxd_buf[8] & 0x04)) ts_temp_up_excution(index,uart2_rxd_buf[9]);
            //if((ts_switch_toggle_bit[index] & 0x08) != (uart2_rxd_buf[8] & 0x08)) ts_temp_down_excution(index,uart2_rxd_buf[9]);
          }
        }   
      }
    }
    ts_switch_toggle_bit[index] = uart2_rxd_buf[8];
    ts_first_power_on[index] = 1;
  }
  else f_ts_power_on[index] = 1;
  
}



void ts_speed_execution(unsigned char index)   
{
  if(room_data_buf[16+index] & 0x04){
    if(room_data_buf[54+index] != 0){
      if(++room_data_buf[54+index] >= 4) room_data_buf[54+index] = 1;
    }
    else{
      room_data_buf[54+index] = room_data_buf[16+index] & 0x03;
      if(++room_data_buf[54+index] >= 4) room_data_buf[54+index] = 1;
    }
    room_data_buf[16+index] |= 0x80;
    room_data_buf[20+index] &= 0xf7;    //Manual mode flag set
    room_data_buf[99] |= 0x02;          //Speed 변경시 온도 상태 전송
  }
  else room_data_buf[54+index] = 0;   //Auto mode
}

void ts_temp_up_excution(unsigned char index, unsigned char ts_mode)
{
  if(ts_mode & 0x01){   //Floor mode
    if(room_data_buf[8+index] & 0x80){
      room_data_buf[8+index] &= 0x7f;
      if((((room_data_buf[29] & 0xf0)>>4)+25) > (room_data_buf[8+index] & 0x80)) ++room_data_buf[8+index];
    }
    else{
      if((((room_data_buf[29] & 0xf0)>>4)+25) > (room_data_buf[8+index] & 0x80)) room_data_buf[8+index] |= 0x80;
    }
  }
  else{                 //Air mode
    if(room_data_buf[0+index] & 0x80){
      room_data_buf[0+index] &= 0x7f;
      if((((room_data_buf[28] & 0xf0)>>4)+25) > (room_data_buf[0+index] & 0x80)) ++room_data_buf[0+index];
    }
    else{
      if((((room_data_buf[28] & 0xf0)>>4)+25) > (room_data_buf[0+index] & 0x80)) room_data_buf[0+index] |= 0x80;
    }
  }
}

void ts_temp_down_excution(unsigned char index, unsigned char ts_mode)
{
  if(ts_mode & 0x01){   //Floor mode
    if(room_data_buf[8+index] & 0x80){
      room_data_buf[8+index] &= 0x7f;
    }
    else{
      if(((room_data_buf[29] & 0x0f)+25) < (room_data_buf[8+index] & 0x80)){
        --room_data_buf[8+index];
        room_data_buf[8+index] |= 0x80;
      }
    }
  }
  else{                 //Air mode
    if(room_data_buf[0+index] & 0x80){
      room_data_buf[0+index] &= 0x7f;
    }
    else{
      if(((room_data_buf[28] & 0x0f)+25) < (room_data_buf[0+index] & 0x80)){
        --room_data_buf[0+index];
        room_data_buf[0+index] |= 0x80;
      }
    }
  }
}

//
//================ Night Table receive data check routine ===============
//

void night_table_check(unsigned char index)
{
  if(f_first_nt_power_on[index]){
    if(room_data_buf[40] & 0x02){   //Guest IN?
      if((nt_switch_toggle_bit[index][0] & 0x01) != (uart2_rxd_buf[4] & 0x01)) nt_switch_bit_check(b_switch_kind_table[0][0],index);
      if((nt_switch_toggle_bit[index][0] & 0x02) != (uart2_rxd_buf[4] & 0x02)) nt_switch_bit_check(b_switch_kind_table[0][1],index);
      if((nt_switch_toggle_bit[index][0] & 0x04) != (uart2_rxd_buf[4] & 0x04)) nt_switch_bit_check(b_switch_kind_table[0][2],index);
      if((nt_switch_toggle_bit[index][0] & 0x08) != (uart2_rxd_buf[4] & 0x08)) nt_switch_bit_check(b_switch_kind_table[0][3],index);
      if((nt_switch_toggle_bit[index][0] & 0x10) != (uart2_rxd_buf[4] & 0x10)) nt_switch_bit_check(b_switch_kind_table[0][4],index);
      if((nt_switch_toggle_bit[index][0] & 0x20) != (uart2_rxd_buf[4] & 0x20)) nt_switch_bit_check(b_switch_kind_table[0][5],index);
      if((nt_switch_toggle_bit[index][0] & 0x40) != (uart2_rxd_buf[4] & 0x40)) nt_switch_bit_check(b_switch_kind_table[0][6],index);
      if((nt_switch_toggle_bit[index][0] & 0x80) != (uart2_rxd_buf[4] & 0x80)) nt_switch_bit_check(b_switch_kind_table[0][7],index);
      
      if((nt_switch_toggle_bit[index][1] & 0x01) != (uart2_rxd_buf[5] & 0x01)) nt_switch_bit_check(b_switch_kind_table[1][0],index);
      if((nt_switch_toggle_bit[index][1] & 0x02) != (uart2_rxd_buf[5] & 0x02)) nt_switch_bit_check(b_switch_kind_table[1][1],index);
      if((nt_switch_toggle_bit[index][1] & 0x04) != (uart2_rxd_buf[5] & 0x04)) nt_switch_bit_check(b_switch_kind_table[1][2],index);
      if((nt_switch_toggle_bit[index][1] & 0x08) != (uart2_rxd_buf[5] & 0x08)) nt_switch_bit_check(b_switch_kind_table[1][3],index);
      if((nt_switch_toggle_bit[index][1] & 0x10) != (uart2_rxd_buf[5] & 0x10)) nt_switch_bit_check(b_switch_kind_table[1][4],index);
      if((nt_switch_toggle_bit[index][1] & 0x20) != (uart2_rxd_buf[5] & 0x20)) nt_switch_bit_check(b_switch_kind_table[1][5],index);
      if((nt_switch_toggle_bit[index][1] & 0x40) != (uart2_rxd_buf[5] & 0x40)) nt_switch_bit_check(b_switch_kind_table[1][6],index);
      if((nt_switch_toggle_bit[index][1] & 0x80) != (uart2_rxd_buf[5] & 0x80)) nt_switch_bit_check(b_switch_kind_table[1][7],index);
    
      if((nt_switch_toggle_bit[index][2] & 0x01) != (uart2_rxd_buf[6] & 0x01)) nt_switch_bit_check(b_switch_kind_table[2][0],index);
      if((nt_switch_toggle_bit[index][2] & 0x02) != (uart2_rxd_buf[6] & 0x02)) nt_switch_bit_check(b_switch_kind_table[2][1],index);
      if((nt_switch_toggle_bit[index][2] & 0x04) != (uart2_rxd_buf[6] & 0x04)) nt_switch_bit_check(b_switch_kind_table[2][2],index);
      if((nt_switch_toggle_bit[index][2] & 0x08) != (uart2_rxd_buf[6] & 0x08)) nt_switch_bit_check(b_switch_kind_table[2][3],index);
      if((nt_switch_toggle_bit[index][2] & 0x10) != (uart2_rxd_buf[6] & 0x10)) nt_switch_bit_check(b_switch_kind_table[2][4],index);
      if((nt_switch_toggle_bit[index][2] & 0x20) != (uart2_rxd_buf[6] & 0x20)) nt_switch_bit_check(b_switch_kind_table[2][5],index);
      if((nt_switch_toggle_bit[index][2] & 0x40) != (uart2_rxd_buf[6] & 0x40)) nt_switch_bit_check(b_switch_kind_table[2][6],index);
      if((nt_switch_toggle_bit[index][2] & 0x80) != (uart2_rxd_buf[6] & 0x80)) nt_switch_bit_check(b_switch_kind_table[2][7],index);
    }
  }
  else f_first_nt_power_on[index] = 1;
  
  nt_switch_toggle_bit[index][0] = uart2_rxd_buf[4];
  nt_switch_toggle_bit[index][1] = uart2_rxd_buf[5];
  nt_switch_toggle_bit[index][2] = uart2_rxd_buf[6];
  
  nt_status[index] = uart2_rxd_buf[7];
/*  if(nt_status[index] & 0x10){
    if(!f_alram_on){
      f_alram_on = 1;
      digital_volume_execution(0,room_data_buf[80]);
    }
  }
  else f_alram_on = 0;*/
  
  if(index == 0){
    if(nt_status[0] & 0x80) room_data_buf[82] |= 0x08;
    else room_data_buf[82] &= 0xf7;
  }
  
  /*
//--- 부전동 호텔 나이트 테이블 온도센서2 역할 처리 ---  
  
  if((uart2_rxd_buf[8] & 0x7f) <= 70){    //Air set temp
    if(room_data_buf[1] != uart2_rxd_buf[8]){
      room_data_buf[17] |= 0x80;
      room_data_buf[1] = uart2_rxd_buf[8];
      room_data_buf[99] |= 0x02;
    }
  }
  
  if(room_data_buf[40] & 0x02){   //Guest IN?
    if(nt_switch_toggle_bit[0][3] != uart2_rxd_buf[9]){    //TS switch push ?
      if((nt_switch_toggle_bit[0][3] & 0x01) != (uart2_rxd_buf[9] & 0x01)){

        room_data_buf[17] ^= 0x04;    //TS Air on/off toggle
        nt_switch_bit_check(K_fcu_auto_manual,1);
        room_data_buf[99] |= 0x02;
        room_data_buf[21] |= 0x08;    //Auto mode flag set
        room_data_buf[17] |= 0x80;

      }              
      
      if((nt_switch_toggle_bit[0][3] & 0x10) != (uart2_rxd_buf[9] & 0x10)) room_data_buf[25] ^= 0x08;    //TS FaC, DoC
      if((nt_switch_toggle_bit[0][3] & 0x20) != (uart2_rxd_buf[9] & 0x20)) ts_speed_execution(1);          //TS local speed execution

    } 
  }  
  nt_switch_toggle_bit[0][3] = uart2_rxd_buf[9];
  */
}

void nt_switch_bit_check(unsigned char key_code, unsigned char index)
{
  switch(key_code)
  {
    case K_stand_master: // LIGHT1(객실), LIGHT2(객실), LIGHT3(객실), Dimming(LED)
      
              if((room_data_buf[45] & 0x06) && (dimmer_level[index] != 0)) 
              {
                room_data_buf[45] &= 0xf1;
                dimmer_level[index] = 0;
              }
              else if(((room_data_buf[45] & 0x06) == 0) && (dimmer_level[index] != 0))
              {
                room_data_buf[45] &= 0xf1;
                dimmer_level[index] = 0;
              }
              else if((room_data_buf[45] & 0x06) &&(dimmer_level[index] == 0))
              {
                room_data_buf[45] &= 0xf1;
                
                dimmer_level[index] = 0;
              }
              else
              {
                room_data_buf[45] |= 0x0e;
                dimmer_level[index] = 0x31;
              }
      
      break;
      
  case K_stand_master_2: //LIGHT5(객실), LIGHT6(객실), LIGHT7(객실), Dimming(LED)
              
              if((room_data_buf[46] & 0x07) && (dimmer_level[index] != 0)) 
              {
                room_data_buf[46] &= 0xf8;
                dimmer_level[index] = 0;
              }
              else if(((room_data_buf[46] & 0x07) == 0) && (dimmer_level[index] != 0))
              {
                room_data_buf[46] &= 0xf8;
                dimmer_level[index] = 0;
              }
              else if((room_data_buf[46] & 0x07) &&(dimmer_level[index] == 0))
              {
                room_data_buf[46] &= 0xf8;
                dimmer_level[index] = 0;
              }
              else
              {
                room_data_buf[46] |= 0x07;
                dimmer_level[index] = 0x31;
              }            
    
      break;
    case K_rest_master:
      
      break;
      
    case K_stand_1:   //LIGHT 1(객실)
              
              if(room_data_buf[45] & 0x02) room_data_buf[45] &= 0xfd;
              else room_data_buf[45] |= 0x02;
              
      break;
      
    case K_stand_2:  //LIGHT 2(객실)
      
              if(room_data_buf[45] & 0x04) room_data_buf[45] &= 0xfb;
              else room_data_buf[45] |= 0x04;
      
      break;
      
    case K_stand_3:  //LIGHT 3(객실)
                      
              if(room_data_buf[45] & 0x08) room_data_buf[45] &= 0xf7;
              else room_data_buf[45] |= 0x08;
      break;
      
    case K_stand_4:   //LIGHT 4(화장실) 
      
            if(room_data_buf[47] & 0x01) room_data_buf[47] &= 0xfe;
            else                         room_data_buf[47] |= 0x01;          
      
    break;
      
    case K_stand_5:   //LIGHT 5(객실)
      
           if(room_data_buf[46] & 0x01) room_data_buf[46] &= 0xfe;
           else room_data_buf[46] |= 0x01;
      
      break;
      
    case K_stand_6:   //LIGHT 6(객실)

          if(room_data_buf[46] & 0x02) room_data_buf[46] &= 0xfd;
          else room_data_buf[46] |= 0x02;
      
      break;
      
    case K_stand_7:   //LIGHT 7(객실)

          if(room_data_buf[46] & 0x04) room_data_buf[46] &= 0xfb;
          else room_data_buf[46] |= 0x04;
      
      break;
      
    case K_bed_master:  

      break;
      

      
      
    case K_exchanger:   //전열교환기
      //if(room_data_buf[46] & 0x04) room_data_buf[46] &= 0xfb;
      //else room_data_buf[46] |= 0x04;
      break;
    case K_entry_lamp:    //입구등
      //if(room_data_buf[45] & 0x02) room_data_buf[45] &= 0xfd;
      //else{
      //  room_data_buf[45] |= 0x02;
       // timer_1sec_entry = 0;
      //  enterance_lamp_delay_timer = 0;
      //  f_enterance_lamp_delay = 0;
      //}
      break;
      
    case K_dim_step_up : 
          if(dimmer_level[index] > 0x31) dimmer_level[index] = 0x31;
          else dimmer_level[index] += 10;
    break;
    
    case K_dim_step_down : 
          if((dimmer_level[index]) < 10) dimmer_level[index] = 0;
          else dimmer_level[index] -= 10;
    break;
    
      
  
    case K_fcu_onoff: room_data_buf[16+index] ^= 0x04;  room_data_buf[16+index] |= 0x80;  room_data_buf[54+index] &= 0xf8;   
      if(room_data_buf[16+index] & 0x04) room_data_buf[20+index] |= 0x08; //auto
      else room_data_buf[20+index] &= 0xf7; //manual
      break;
    case K_fcu_low:   room_data_buf[16+index] |= 0x04;  room_data_buf[16+index] |= 0x80;  room_data_buf[54+index] &= 0xf8;   room_data_buf[54+index] |= 0x01;  
      room_data_buf[20+index] &= 0xf7; //manual
      break;
    case K_fcu_mid:   room_data_buf[16+index] |= 0x04;  room_data_buf[16+index] |= 0x80;  room_data_buf[54+index] &= 0xf8;   room_data_buf[54+index] |= 0x02;  
      room_data_buf[20+index] &= 0xf7; //manual
      break;
    case K_fcu_high:  room_data_buf[16+index] |= 0x04;  room_data_buf[16+index] |= 0x80;  room_data_buf[54+index] &= 0xf8;   room_data_buf[54+index] |= 0x03;  
      room_data_buf[20+index] &= 0xf7; //manual
      break;
    case K_fcu_auto_manual: room_data_buf[54+index] &= 0xf8;  room_data_buf[16+index] |= 0x80; break;
  
    case K_dnd: dnd_mur_execution('D','T'); break;
    case K_mur: dnd_mur_execution('M','T'); break;
    case K_call_wait:
    case K_emergency:
    case K_chime_push:
      break;
      
      
      

  }
  
}

//
//=============== Light switch receive data check routine ==============================
//
void light_switch_check(unsigned char index)
{
  if(f_first_ls_power_on[index])
  {
      if(room_data_buf[40] & 0x02){   //Guest IN?
        if((light_switch_toggle_bit[index][0] & 0x01) != (uart2_rxd_buf[4] & 0x01)) nt_switch_bit_check(b_ls_switch_kind_table[index][0],index);
        if((light_switch_toggle_bit[index][0] & 0x02) != (uart2_rxd_buf[4] & 0x02)) nt_switch_bit_check(b_ls_switch_kind_table[index][1],index);
        if((light_switch_toggle_bit[index][0] & 0x04) != (uart2_rxd_buf[4] & 0x04)) nt_switch_bit_check(b_ls_switch_kind_table[index][2],index);
        if((light_switch_toggle_bit[index][0] & 0x08) != (uart2_rxd_buf[4] & 0x08)) nt_switch_bit_check(b_ls_switch_kind_table[index][3],index);
        if((light_switch_toggle_bit[index][0] & 0x10) != (uart2_rxd_buf[4] & 0x10)) nt_switch_bit_check(b_ls_switch_kind_table[index][4],index);
        if((light_switch_toggle_bit[index][0] & 0x20) != (uart2_rxd_buf[4] & 0x20)) nt_switch_bit_check(b_ls_switch_kind_table[index][5],index);
      }
     
  }
  else f_first_ls_power_on[index] = 1;
  
  light_switch_toggle_bit[index][0] = uart2_rxd_buf[4];
  
}

//
//========================= dimmer receive data check routine =============================
//
void dimmer_check(unsigned char index)
{
  if(f_first_dimmer_power_on[index])
  {
    
    
  }
  else f_first_dimmer_power_on[index] = 1;
     
  dimmer_switch_toggle_bit[index] = uart2_rxd_buf[4];
}

void chime_ind_check(unsigned char index)
{
  if(f_first_ci_power_on[index])
  {
    if((chime_ind_toggle_bit[index] & 0x01) != (uart2_rxd_buf[4] & 0x01))
   {
      if(!f_chime_keep)
      {
        f_chime_keep = 1;
        chime_sq = 0;
        f_chime_sq_timer = 1;
        digital_volume_execution(0,room_data_buf[79]);
        
        handy_sign_timer = 0;
        if(room_data_buf[40] & 0x02) // 입실일때
        {
          room_data_buf[48] |= 0x80;
          f_chime_sign = 1;
        }
        
      }
    }
  }
  else f_first_ci_power_on[index] = 1;
   
  chime_ind_toggle_bit[index] = uart2_rxd_buf[4]; 
}

void chime_ex_sub_check(void)
{
      if(!f_chime_keep)
      {
        f_chime_keep = 1;
        chime_sq = 0;
        f_chime_sq_timer = 1;
        digital_volume_execution(0,room_data_buf[79]);
        
        handy_sign_timer = 0;
        if(room_data_buf[40] & 0x02) // 입실일때
        {
          room_data_buf[48] |= 0x80;
          f_chime_sign = 1;
        }
        
      } 
}

//
//=============== Key sensor receive data check routine =================
//
void key_sensor_rx_check(unsigned char index)
{
  if(f_first_ks_power_on[index])
  {
    if((ks_switch_toggle_bit[index] & 0x01) != (uart2_rxd_buf[4] & 0x01))
    {
      nt_switch_bit_check(K_dnd, index);
    }
    if((ks_switch_toggle_bit[index] & 0x02) != (uart2_rxd_buf[4] & 0x02))
    {
      nt_switch_bit_check(K_mur, index);
    }
  }
  else f_first_ks_power_on[index] = 1; 
  
  ks_switch_toggle_bit[index] = uart2_rxd_buf[4];
  
  if(dip_switch_buf[0] & 0x40){   //통신형 K/S 사용하는가?
    f_ks_rx_ok = 1;
    ks_rx_timer = 0;
    ks_key_status = uart2_rxd_buf[6];
    f_ks_error = 0;
  }
  
}

//=======================================================================
//=======================================================================

